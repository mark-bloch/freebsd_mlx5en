From: Erez Shitrit <erezsh@mellanox.com>
Subject: [PATCH] BACKPORTS: net/eipoib: backport rx handler to 2.6.32

The eipoib driver uses the netdev_rx_handler_register framework
to register a handler which hooks all the rx calls made by ipoib
devices which are in use by eipoib.  In 2.6.32 there's no such generic
mechanism, and hence we went in the ugly way of using a function pointer
exported by IPoIB and filled by eIPoIB.

This works but creates explicit dependancy between the modules,
which has the side effect of IPoIB to be unloaded when one does
modprobe -r on eIPoIB. We can try and fix that out using things
like symbol_get/put

Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
Signed-off-by: Erez Shitrit <erezsh@mellanox.com>
---
 drivers/net/eipoib/eth_ipoib_main.c |   35 +++++++++++++++++++++++++++++++++--
 1 files changed, 33 insertions(+), 2 deletions(-)

diff --git a/drivers/net/eipoib/eth_ipoib_main.c b/drivers/net/eipoib/eth_ipoib_main.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/eipoib/eth_ipoib_main.c
+++ b/drivers/net/eipoib/eth_ipoib_main.c
@@ -57,6 +57,12 @@
 #define PARENT_MAC_MASK 0xe7
 
 /* forward declaration */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36))
+typedef int rx_handler_result_t;
+#define RX_HANDLER_CONSUMED 0
+extern int (*eth_ipoib_handle_frame_hook)(struct sk_buff **skb);
+#endif
+
 static rx_handler_result_t eipoib_handle_frame(struct sk_buff **pskb);
 static int eipoib_device_event(struct notifier_block *unused,
 			       unsigned long event, void *ptr);
@@ -586,6 +592,7 @@ int parent_enslave(struct net_device *parent_dev, struct net_device *slave_dev)
 	if (res)
 		goto err_close;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	/* register handler */
 	res = netdev_rx_handler_register(slave_dev, eipoib_handle_frame,
 					 new_slave);
@@ -594,6 +601,9 @@ int parent_enslave(struct net_device *parent_dev, struct net_device *slave_dev)
 			parent_dev->name, res);
 		goto err_close;
 	}
+#else
+	slave_dev->ax25_ptr = new_slave;
+#endif
 
 	pr_info("%s: enslaving %s\n", parent_dev->name, slave_dev->name);
 
@@ -687,8 +697,9 @@ int parent_release_slave(struct net_device *parent_dev,
 	write_unlock_bh(&parent->lock);
 
 	/* must do this from outside any spinlocks */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	netdev_rx_handler_unregister(slave->dev);
-
+#endif
 	destroy_slave_symlinks(parent_dev, slave_dev);
 
 	netdev_set_parent_master(slave_dev, NULL);
@@ -790,7 +801,11 @@ static struct neigh *neigh_find(struct hlist_head *head,
 	struct neigh *neigh;
 
 	hlist_for_each_entry(neigh, h, head, hlist) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0))
 		if (ether_addr_equal(neigh->emac, addr))
+#else
+		if (!memcmp(neigh->emac, addr,ETH_ALEN))
+#endif
 			return neigh;
 	}
 	return NULL;
@@ -803,7 +818,12 @@ static struct neigh *neigh_find_rcu(struct hlist_head *head,
 	struct neigh *neigh;
 
 	hlist_for_each_entry_rcu(neigh, h, head, hlist) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0))
 		if (ether_addr_equal(neigh->emac, addr))
+#else
+                if (!memcmp(neigh->emac, addr,ETH_ALEN))
+#endif
+
 			return neigh;
 	}
 	return NULL;
@@ -1898,8 +1918,11 @@ static rx_handler_result_t eipoib_handle_frame(struct sk_buff **pskb)
 	struct slave *slave;
 	rcu_read_lock_bh();
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	slave = eipoib_slave_get_rcu(skb->dev);
-
+#else
+	slave = (struct slave *)skb->dev->ax25_ptr;
+#endif
 	parent_rx(skb, slave);
 
 	rcu_read_unlock_bh();
@@ -2465,6 +2488,10 @@ static int __init mod_init(void)
 		goto unreg_subsys;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36))
+	eth_ipoib_handle_frame_hook = eipoib_handle_frame;
+#endif
+
 	goto out;
 
 unreg_subsys:
@@ -2480,6 +2507,10 @@ static void __exit mod_exit(void)
 
 	unregister_pernet_subsys(&eipoib_net_ops);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36))
+	eth_ipoib_handle_frame_hook = NULL;
+#endif
+
 	rtnl_lock();
 	parent_free_all();
 	rtnl_unlock();
