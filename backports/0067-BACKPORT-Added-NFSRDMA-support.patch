From: Vladimir Sokolovsky <vlad@mellanox.com>
Subject: [PATCH] BACKPORT: Added NFSRDMA support

Change-Id: Ie034ec82aab6a085f572a53e0dea0e7c8e8ade85
Signed-off-by: Vladimir Sokolovsky <vlad@mellanox.com>
---
 net/sunrpc/xprtrdma/rpc_rdma.c           |   16 ++++++++++++++++
 net/sunrpc/xprtrdma/svc_rdma_transport.c |    4 ++++
 net/sunrpc/xprtrdma/transport.c          |   22 ++++++++++++++++++++++
 3 files changed, 42 insertions(+), 0 deletions(-)

diff --git a/net/sunrpc/xprtrdma/rpc_rdma.c b/net/sunrpc/xprtrdma/rpc_rdma.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/net/sunrpc/xprtrdma/rpc_rdma.c
+++ b/net/sunrpc/xprtrdma/rpc_rdma.c
@@ -338,9 +338,17 @@ rpcrdma_inline_pullup(struct rpc_rqst *rqst, int pad)
 			curlen = copy_len;
 		dprintk("RPC:       %s: page %d destp 0x%p len %d curlen %d\n",
 			__func__, i, destp, copy_len, curlen);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 		srcp = kmap_atomic(ppages[i]);
+#else
+		srcp = kmap_atomic(ppages[i], KM_SKB_SUNRPC_DATA);
+#endif
 		memcpy(destp, srcp+page_base, curlen);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 		kunmap_atomic(srcp);
+#else
+		kunmap_atomic(srcp, KM_SKB_SUNRPC_DATA);
+#endif
 		rqst->rq_svec[0].iov_len += curlen;
 		destp += curlen;
 		copy_len -= curlen;
@@ -639,10 +647,18 @@ rpcrdma_inline_fixup(struct rpc_rqst *rqst, char *srcp, int copy_len, int pad)
 			dprintk("RPC:       %s: page %d"
 				" srcp 0x%p len %d curlen %d\n",
 				__func__, i, srcp, copy_len, curlen);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 			destp = kmap_atomic(ppages[i]);
+#else
+			destp = kmap_atomic(ppages[i], KM_SKB_SUNRPC_DATA);
+#endif
 			memcpy(destp + page_base, srcp, curlen);
 			flush_dcache_page(ppages[i]);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 			kunmap_atomic(destp);
+#else
+			kunmap_atomic(destp, KM_SKB_SUNRPC_DATA);
+#endif
 			srcp += curlen;
 			copy_len -= curlen;
 			if (copy_len == 0)
diff --git a/net/sunrpc/xprtrdma/svc_rdma_transport.c b/net/sunrpc/xprtrdma/svc_rdma_transport.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/net/sunrpc/xprtrdma/svc_rdma_transport.c
+++ b/net/sunrpc/xprtrdma/svc_rdma_transport.c
@@ -445,7 +445,11 @@ static struct svcxprt_rdma *rdma_create_xprt(struct svc_serv *serv,
 
 	if (!cma_xprt)
 		return NULL;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
 	svc_xprt_init(&init_net, &svc_rdma_class, &cma_xprt->sc_xprt, serv);
+#else
+	svc_xprt_init(&svc_rdma_class, &cma_xprt->sc_xprt, serv);
+#endif
 	INIT_LIST_HEAD(&cma_xprt->sc_accept_q);
 	INIT_LIST_HEAD(&cma_xprt->sc_dto_q);
 	INIT_LIST_HEAD(&cma_xprt->sc_rq_dto_q);
diff --git a/net/sunrpc/xprtrdma/transport.c b/net/sunrpc/xprtrdma/transport.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/net/sunrpc/xprtrdma/transport.c
+++ b/net/sunrpc/xprtrdma/transport.c
@@ -277,8 +277,14 @@ xprt_setup_rdma(struct xprt_create *args)
 		return ERR_PTR(-EBADF);
 	}
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37) || defined (CONFIG_COMPAT_XPRTRDMA_NEEDED))
 	xprt = xprt_alloc(args->net, sizeof(struct rpcrdma_xprt),
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0) || defined (CONFIG_COMPAT_XPRT_ALLOC_4PARAMS))
 			xprt_rdma_slot_table_entries,
+#endif
+#else
+	xprt = xprt_alloc(sizeof(struct rpcrdma_xprt),
+#endif
 			xprt_rdma_slot_table_entries);
 	if (xprt == NULL) {
 		dprintk("RPC:       %s: couldn't allocate rpcrdma_xprt\n",
@@ -448,8 +454,14 @@ xprt_rdma_connect(struct rpc_task *task)
 }
 
 static int
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0) || defined (CONFIG_COMPAT_XPRTRDMA_NEEDED))
 xprt_rdma_reserve_xprt(struct rpc_xprt *xprt, struct rpc_task *task)
 {
+#else
+xprt_rdma_reserve_xprt(struct rpc_task *task)
+{
+	struct rpc_xprt *xprt = task->tk_xprt;
+#endif
 	struct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);
 	int credits = atomic_read(&r_xprt->rx_buf.rb_credits);
 
@@ -461,7 +473,11 @@ xprt_rdma_reserve_xprt(struct rpc_xprt *xprt, struct rpc_task *task)
 		BUG_ON(r_xprt->rx_buf.rb_cwndscale <= 0);
 	}
 	xprt->cwnd = credits * r_xprt->rx_buf.rb_cwndscale;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0) || defined (CONFIG_COMPAT_XPRT_RESERVE_XPRT_CONG_2PARAMS))
 	return xprt_reserve_xprt_cong(xprt, task);
+#else
+	return xprt_reserve_xprt_cong(task);
+#endif
 }
 
 /*
@@ -656,7 +672,11 @@ xprt_rdma_send_request(struct rpc_task *task)
 	if (rpcrdma_ep_post(&r_xprt->rx_ia, &r_xprt->rx_ep, req))
 		goto drop_connection;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35) || defined (CONFIG_COMPAT_XPRTRDMA_NEEDED))
 	rqst->rq_xmit_bytes_sent += rqst->rq_snd_buf.len;
+#else
+	task->tk_bytes_sent += rqst->rq_snd_buf.len;
+#endif
 	rqst->rq_bytes_sent = 0;
 	return 0;
 
@@ -707,7 +727,9 @@ static void xprt_rdma_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)
 static struct rpc_xprt_ops xprt_rdma_procs = {
 	.reserve_xprt		= xprt_rdma_reserve_xprt,
 	.release_xprt		= xprt_release_xprt_cong, /* sunrpc/xprt.c */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
 	.alloc_slot		= xprt_alloc_slot,
+#endif
 	.release_request	= xprt_release_rqst_cong,       /* ditto */
 	.set_retrans_timeout	= xprt_set_retrans_timeout_def, /* ditto */
 	.rpcbind		= rpcb_getport_async,	/* sunrpc/rpcb_clnt.c */
