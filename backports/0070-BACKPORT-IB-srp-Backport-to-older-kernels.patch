From: Vu Pham <vuhuong@mellanox.com>
Subject: [PATCH] BACKPORT: IB/srp Backport to older kernels

This patch has been tested on RHEL/OEL 6.x (0-4)
SLES 11sp2, 11sp3, Ubuntu 10.04, debian 6.

Change-Id: Ia002bec91032d1d08715268c2fbf19a1e193892c
Signed-off-by: Bart Van Assche <bvanassche@acm.org>
Signed-off-by: Vu Pham <vuhuong@mellanox.com>
Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
---
 drivers/infiniband/ulp/srp/ib_srp.c |   87 ++++++++++++++++++++++++++++++++++-
 drivers/scsi/scsi_transport_srp.c   |   30 ++++++++++++
 2 files changed, 116 insertions(+), 1 deletions(-)

diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@ -35,6 +35,7 @@
 #endif
 #define pr_fmt(fmt) PFX fmt
 
+#include <linux/version.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
@@ -44,7 +45,11 @@
 #include <linux/random.h>
 #include <linux/jiffies.h>
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)
 #include <linux/atomic.h>
+#else
+#include <asm/atomic.h>
+#endif
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_device.h>
@@ -59,6 +64,10 @@
 #define DRV_VERSION	"1.3.1"
 #define DRV_RELDATE	"July 1, 2013"
 
+#ifndef pr_warn
+#define pr_warn pr_warning
+#endif
+
 MODULE_AUTHOR("Roland Dreier");
 MODULE_DESCRIPTION("InfiniBand SCSI RDMA Protocol initiator");
 MODULE_LICENSE("Dual BSD/GPL");
@@ -95,21 +104,35 @@ static int srp_reconnect_delay = 10;
 module_param_named(reconnect_delay, srp_reconnect_delay, int, S_IRUGO|S_IWUSR);
 MODULE_PARM_DESC(reconnect_delay, "Time between successive reconnect attempts");
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 static struct kernel_param_ops srp_tmo_ops;
+#endif
 
 static int srp_fast_io_fail_tmo = 15;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 module_param_cb(fast_io_fail_tmo, &srp_tmo_ops, &srp_fast_io_fail_tmo,
 		S_IRUGO | S_IWUSR);
+#else
+module_param_named(fast_io_fail_tmo, srp_fast_io_fail_tmo, int, S_IRUGO|S_IWUSR);
+#endif
 MODULE_PARM_DESC(fast_io_fail_tmo,
 		 "Number of seconds between the observation of a transport"
 		 " layer error and failing all I/O.\n"
 		 "                             "
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 		 "\"off\" means that this"
+#else
+		 "(-1) means that this"
+#endif
 		 " functionality is disabled.");
 
 static int srp_dev_loss_tmo = -1;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 module_param_cb(dev_loss_tmo, &srp_tmo_ops, &srp_dev_loss_tmo,
 		S_IRUGO | S_IWUSR);
+#else
+module_param_named(dev_loss_tmo, srp_dev_loss_tmo, int, S_IRUGO|S_IWUSR);
+#endif
 MODULE_PARM_DESC(dev_loss_tmo,
 		 "Maximum number of seconds that the SRP transport should"
 		 " insulate transport layer errors.\n"
@@ -119,7 +142,11 @@ MODULE_PARM_DESC(dev_loss_tmo,
 		 "Should be between 1 and " __stringify(SCSI_DEVICE_BLOCK_MAX_TIMEOUT)
 		 " if fast_io_fail_tmo has not been set.\n"
 		 "                             "
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 		 "\"off\" means that this functionality is disabled.");
+#else
+		 "(-1) means that this functionality is disabled.");
+#endif
 
 static void srp_add_one(struct ib_device *device);
 static void srp_remove_one(struct ib_device *device);
@@ -137,6 +164,7 @@ static struct ib_client srp_client = {
 
 static struct ib_sa_client srp_sa_client;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 static int srp_tmo_get(char *buffer, const struct kernel_param *kp)
 {
 	int tmo = *(int *)kp->arg;
@@ -178,6 +206,7 @@ static struct kernel_param_ops srp_tmo_ops = {
 	.get = srp_tmo_get,
 	.set = srp_tmo_set,
 };
+#endif
 
 static inline struct srp_target_port *host_to_target(struct Scsi_Host *host)
 {
@@ -1512,7 +1541,50 @@ static void srp_send_completion(struct ib_cq *cq, void *target_ptr)
 	}
 }
 
-static int srp_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *scmnd)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+/*
+ * Kernel with host lock push-down patch. See also upstream commit
+ * f281233d3eba15fb225d21ae2e228fd4553d824a.
+ */
+#define SRP_QUEUECOMMAND srp_queuecommand
+#elif defined(RHEL_MAJOR) && RHEL_MAJOR -0 == 6 && RHEL_MINOR -0 >= 2
+/*
+ * Kernel with lockless SCSI command dispatching enabled.
+ * See also the RHEL 6.2 release notes (http://access.redhat.com/knowledge/docs/en-US/Red_Hat_Enterprise_Linux/6/html-single/6.2_Release_Notes/index.html).
+ */
+static int srp_queuecommand_wrk(struct Scsi_Host *shost,
+				struct scsi_cmnd *scmnd);
+static int srp_queuecommand(struct scsi_cmnd *scmnd,
+			    void (*done)(struct scsi_cmnd *))
+{
+	scmnd->scsi_done = done;
+	return srp_queuecommand_wrk(scmnd->device->host, scmnd);
+}
+#define SRP_QUEUECOMMAND srp_queuecommand_wrk
+#else
+/*
+ * Kernel that invokes srp_queuecommand with the SCSI host lock held.
+ */
+static int srp_queuecommand_wrk(struct Scsi_Host *shost,
+				struct scsi_cmnd *scmnd);
+static int srp_queuecommand(struct scsi_cmnd *scmnd,
+			    void (*done)(struct scsi_cmnd *))
+{
+	struct Scsi_Host *shost = scmnd->device->host;
+	int res;
+
+	spin_unlock_irq(shost->host_lock);
+
+	scmnd->scsi_done = done;
+	res = srp_queuecommand_wrk(shost, scmnd);
+
+	spin_lock_irq(shost->host_lock);
+	return res;
+}
+#define SRP_QUEUECOMMAND srp_queuecommand_wrk
+#endif
+
+static int SRP_QUEUECOMMAND(struct Scsi_Host *shost, struct scsi_cmnd *scmnd)
 {
 	struct srp_target_port *target = host_to_target(shost);
 	struct srp_request *req;
@@ -1942,8 +2014,10 @@ static int srp_abort(struct scsi_cmnd *scmnd)
 	if (srp_send_tsk_mgmt(target, req->index, scmnd->device->lun,
 			      SRP_TSK_ABORT_TASK) == 0)
 		ret = SUCCESS;
+#if defined(SRP_NO_FAST_IO_FAIL)
 	else if (target->rport->state == SRP_RPORT_LOST)
 		ret = FAST_IO_FAIL;
+#endif
 	else
 		ret = FAILED;
 	srp_free_req(target, req, scmnd, 0);
@@ -2154,6 +2228,9 @@ static struct scsi_host_template srp_template = {
 	.proc_name			= DRV_NAME,
 	.slave_configure		= srp_slave_configure,
 	.info				= srp_target_info,
+#if defined(RHEL_MAJOR) && RHEL_MAJOR -0 == 6 && RHEL_MINOR -0 >= 2
+	.lockless			= true,
+#endif
 	.queuecommand			= srp_queuecommand,
 	.eh_abort_handler		= srp_abort,
 	.eh_device_reset_handler	= srp_reset_device,
@@ -2852,6 +2929,14 @@ static int __init srp_init_module(void)
 {
 	int ret;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
+	if (srp_tmo_valid(srp_reconnect_delay, srp_fast_io_fail_tmo,
+			  srp_dev_loss_tmo)) {
+		pr_warn("Bad module parameters provided\n");
+		return -EINVAL;
+	}
+#endif
+
 	BUILD_BUG_ON(FIELD_SIZEOF(struct ib_wc, wr_id) < sizeof(void *));
 
 	if (srp_mod_param_valid()) {
diff --git a/drivers/scsi/scsi_transport_srp.c b/drivers/scsi/scsi_transport_srp.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/scsi/scsi_transport_srp.c
+++ b/drivers/scsi/scsi_transport_srp.c
@@ -377,6 +377,7 @@ invalid:
  */
 static int scsi_request_fn_active(struct Scsi_Host *shost)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	struct scsi_device *sdev;
 	struct request_queue *q;
 	int request_fn_active = 0;
@@ -390,6 +391,10 @@ static int scsi_request_fn_active(struct Scsi_Host *shost)
 	}
 
 	return request_fn_active;
+#else
+	msleep(20);
+	return 0;
+#endif
 }
 
 /**
@@ -427,7 +432,11 @@ int srp_reconnect_rport(struct srp_rport *rport)
 
 		rport->failed_reconnects = 0;
 		srp_rport_set_state(rport, SRP_RPORT_RUNNING);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0) || defined(CONFIG_COMPAT_SCSI_TARGET_UNBLOCK)
 		scsi_target_unblock(&shost->shost_gendev, SDEV_RUNNING);
+#else
+		scsi_target_unblock(&shost->shost_gendev);
+#endif
 		/*
 		 * It can occur that after fast_io_fail_tmo expired and before
 		 * dev_loss_tmo expired that the SCSI error handler has
@@ -441,8 +450,12 @@ int srp_reconnect_rport(struct srp_rport *rport)
 				sdev->sdev_state = SDEV_RUNNING;
 		spin_unlock_irq(shost->host_lock);
 	} else if (rport->state != SRP_RPORT_BLOCKED) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0) || defined(CONFIG_COMPAT_SCSI_TARGET_UNBLOCK)
 		scsi_target_unblock(&shost->shost_gendev,
 				    SDEV_TRANSPORT_OFFLINE);
+#else
+		scsi_target_unblock(&shost->shost_gendev);
+#endif
 	}
 	mutex_unlock(&rport->mutex);
 
@@ -483,7 +496,11 @@ static void __rport_fail_io_fast(struct srp_rport *rport)
 
 	if (srp_rport_set_state(rport, SRP_RPORT_FAIL_FAST))
 		return;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0) || defined(CONFIG_COMPAT_SCSI_TARGET_UNBLOCK)
 	scsi_target_unblock(rport->dev.parent, SDEV_TRANSPORT_OFFLINE);
+#else
+	scsi_target_unblock(rport->dev.parent);
+#endif
 
 	/* Involve the LLD if possible to terminate all I/O on the rport. */
 	i = to_srp_internal(shost->transportt);
@@ -523,7 +540,11 @@ static void rport_dev_loss_timedout(struct work_struct *work)
 
 	mutex_lock(&rport->mutex);
 	WARN_ON(srp_rport_set_state(rport, SRP_RPORT_LOST) != 0);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0) || defined(CONFIG_COMPAT_SCSI_TARGET_UNBLOCK)
 	scsi_target_unblock(rport->dev.parent, SDEV_TRANSPORT_OFFLINE);
+#else
+	scsi_target_unblock(rport->dev.parent);
+#endif
 	mutex_unlock(&rport->mutex);
 
 	i->f->rport_delete(rport);
@@ -570,8 +591,12 @@ void srp_start_tl_fail_timers(struct srp_rport *rport)
 		pr_debug("%s has already been deleted\n",
 			 dev_name(&shost->shost_gendev));
 		srp_rport_set_state(rport, SRP_RPORT_FAIL_FAST);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0) || defined(CONFIG_COMPAT_SCSI_TARGET_UNBLOCK)
 		scsi_target_unblock(&shost->shost_gendev,
 				    SDEV_TRANSPORT_OFFLINE);
+#else
+		scsi_target_unblock(&shost->shost_gendev);
+#endif
 	}
 	mutex_unlock(&rport->mutex);
 }
@@ -722,6 +747,7 @@ struct srp_rport *srp_rport_add(struct Scsi_Host *shost,
 		return ERR_PTR(ret);
 	}
 
+#if 0
 	if (shost->active_mode & MODE_TARGET &&
 	    ids->roles == SRP_RPORT_ROLE_INITIATOR) {
 		ret = srp_tgt_it_nexus_create(shost, (unsigned long)rport,
@@ -733,6 +759,7 @@ struct srp_rport *srp_rport_add(struct Scsi_Host *shost,
 			return ERR_PTR(ret);
 		}
 	}
+#endif
 
 	transport_add_device(&rport->dev);
 	transport_configure_device(&rport->dev);
@@ -750,11 +777,13 @@ EXPORT_SYMBOL_GPL(srp_rport_add);
 void srp_rport_del(struct srp_rport *rport)
 {
 	struct device *dev = &rport->dev;
+#if 0
 	struct Scsi_Host *shost = dev_to_shost(dev->parent);
 
 	if (shost->active_mode & MODE_TARGET &&
 	    rport->roles == SRP_RPORT_ROLE_INITIATOR)
 		srp_tgt_it_nexus_destroy(shost, (unsigned long)rport);
+#endif
 
 	transport_remove_device(dev);
 	device_del(dev);
@@ -885,6 +914,7 @@ static __init int srp_transport_init(void)
 		goto unregister_host_class;
 
 	return 0;
+
 unregister_host_class:
 	transport_class_unregister(&srp_host_class);
 	return ret;
