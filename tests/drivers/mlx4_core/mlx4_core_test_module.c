#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <linux/mlx4/driver.h>
#include "mlx4_core_test_module.h"

/*****************************************************************************************************************************/
/*****************************************************************************************************************************/
/**************************************** TEST MODULE - DO NOT EDIT THIS FILE ************************************************/
/*****************************************************************************************************************************/
/*****************************************************************************************************************************/



/************************************/
/************** macros **************/
/************************************/

// map test status to integer
#define TEST_READY      "ready"
#define TEST_RUN        "run"
#define TEST_RUNNING    "running"


/************************************/
/********* mlx4 interface ***********/
/************************************/

struct device_element {
        struct mlx4_dev *p_dev;
        struct device_element *next;
};
typedef struct device_element* dev_list_t;

dev_list_t device_list_head = NULL;
dev_list_t last_device = NULL;
int     mlx4_registered = 0;

// This function must return a non-NULL value in case of success
static void *mlx4_core_add_device(struct mlx4_dev *dev) {
        uprintf("adding device \n");
        
        if (NULL == dev) {
                uprintf("Failed adding device \n");
                return NULL;
        }
        
        if (NULL == device_list_head) {
                device_list_head = malloc(sizeof(struct device_element), M_TEMP, M_WAITOK);
                device_list_head->p_dev = dev;
                device_list_head->next = NULL;
                last_device = device_list_head;
        }
        else {
                dev_list_t curr_device = malloc(sizeof(struct device_element), M_TEMP, M_WAITOK);
                curr_device->p_dev = dev;
                curr_device->next = NULL;
        
                last_device->next = curr_device;
                last_device = curr_device;
        }

        uprintf("added device %p with board id = %s \n", dev, dev->board_id);
       
        return dev;
}

static void mlx4_core_remove_device(struct mlx4_dev *dev, void *context) {
        uprintf("removing device %p with board id = %s \n", dev, dev->board_id);
        dev_list_t curr_device = device_list_head;
        dev_list_t prev_device = NULL;
        
        if (device_list_head->p_dev == dev) {
                // the removed device is first on list
                // if the head is also the last element on the list, device_list_head will be null
                device_list_head = device_list_head->next; 
                if (NULL == device_list_head) {
                        // list is now empty
                        uprintf("list of devices is now empty... \n");
                        last_device = NULL;
                }

                free(curr_device, M_TEMP);
                return;
        }

        // the device removed is not the head of the list
        while (NULL != curr_device) {
                if (curr_device->p_dev == dev) {
                        // found the removed device
                        if (NULL != prev_device) {
                                prev_device->next = curr_device->next;
                        }

                        if (last_device->p_dev == dev) {
                                // update last device on list
                                last_device = prev_device;
                        }
                        
                        free(curr_device, M_TEMP);
                        return;
                }

                prev_device = curr_device;
                curr_device = curr_device->next;
        }

        uprintf("Failed removing device %p with board id = %s - device not found on list \n", dev, dev->board_id);
}

static struct mlx4_interface mlx4_core_test_interface = {
        .add            = mlx4_core_add_device,
        .remove         = mlx4_core_remove_device,
//        .event          = mlx4_core_test_event,
        .protocol       = 0
};

static int register_mlx4(void) {
        int err = mlx4_register_interface(&mlx4_core_test_interface);
        if (err) {
                uprintf("ERROR %d: Failed registering to an mlx4 device \n", err);
        }
        else {
                mlx4_registered = 1;
                uprintf("Succeeded to register to an mlx4 device \n");
        }
        
        return err; // 0 iff registration passed
}


/************************************/
/****** module implementation *******/
/************************************/

// sysctl related parameters
static struct sysctl_ctx_list clist;

static int find_test_index_from_test_result_oidp(struct sysctl_oid *oidp) {
        for (int i = 0; i < num_of_test_cases; i++) {
                if (tests[i].result_oidp == oidp) {
                        return i;
                }
        }

        return -1;
}

static int sysctl_run_test(SYSCTL_HANDLER_ARGS) {
        int index = find_test_index_from_test_result_oidp(oidp);
        if (index == -1) {
                return 1;
        }
        
        // if sysctl status in not set to "run", simply return the current test result
        if (strcmp(tests[index].status, TEST_RUN)) { //TODO - case insensetive
                sysctl_handle_string(oidp, tests[index].result, 0, req);
                return 0;
        }

        // else, status is set to "run" -
        // change it to "running", so that in case of reading, it won't run again
        strcpy(tests[index].status, TEST_RUNNING);

        // check at the beginning of the test if we registered to mlx4 interface
        if (! mlx4_registered) {
                int err = register_mlx4();
                if (err) {
                        tests[index].result[0] = '1';
                        tests[index].result[1] = ' '; // white-space between the returned value and the log

                        strcpy(tests[index].result + 2, "Failed registering to mlx4 interface");
                        return 0;
                }
        }
        
        // run the test
        static char log[BUFF_SIZE];
        memset(log, 0, BUFF_SIZE);

        int rc = tests[index].func(device_list_head->p_dev, log); //TODO: currently pass only the first device... need fix
        tests[index].result[0] = (rc == 0 ? '0' : '1');
        tests[index].result[1] = ' '; // white-space between the returned value and the log

        strcpy(tests[index].result + 2, log);
        
        sysctl_handle_string(oidp, tests[index].result, 0, req);
        strcpy(tests[index].status, TEST_READY);
       
        return 0;
}

static int init_sysctl(void)
{
        static struct sysctl_oid *mlx4_core_oidp;
        static struct sysctl_oid *infiniband_oidp;
        static struct sysctl_oid *oidp;
        
        sysctl_ctx_init(&clist);

        infiniband_oidp = SYSCTL_ADD_NODE(&clist, SYSCTL_STATIC_CHILDREN(_debug), OID_AUTO, "infiniband", CTLFLAG_RW, 0, "infiniband tests root node");
        if (infiniband_oidp == NULL) {
                uprintf("SYSCTL_ADD_NODE (infiniband) failed \n");
                return EINVAL;
        }

        mlx4_core_oidp = SYSCTL_ADD_NODE(&clist, SYSCTL_CHILDREN(infiniband_oidp), OID_AUTO, "mlx4_core", CTLFLAG_RW, 0, "mlx4_core tests root node");
        if (mlx4_core_oidp == NULL) {
                uprintf("SYSCTL_ADD_NODE (mlx4_core) failed \n");
                return EINVAL;
        }
        
        for (int i = 0; i < num_of_test_cases; i++) {
                uprintf("Adding test: %s (%s) \n", tests[i].name, tests[i].desc);
                
                // adding a new subcategory for the test
                oidp = SYSCTL_ADD_NODE(&clist, SYSCTL_CHILDREN(mlx4_core_oidp), OID_AUTO, tests[i].name, CTLFLAG_RW, 0, tests[i].desc);
                if (oidp == NULL) {
                        uprintf("SYSCTL_ADD_NODE %s failed \n", tests[i].name);
                        return EINVAL;
                }

                strcpy(tests[i].status, TEST_READY);
                strcpy(tests[i].result, "NA");

                // adding proc leaf
                // when reading the leaf, the test will run
                tests[i].result_oidp = SYSCTL_ADD_PROC(&clist, SYSCTL_CHILDREN(oidp), OID_AUTO, "result", CTLTYPE_STRING | CTLFLAG_RD, 
                                                            0, 0, sysctl_run_test, "A", "result leaf");
                // adding int leaf for running the test
                SYSCTL_ADD_STRING(&clist, SYSCTL_CHILDREN(oidp), OID_AUTO, "status", CTLFLAG_RW, &tests[i].status, BUFF_SIZE - 1, "status leaf");
        }

        return 0;
}

static void cleanup_module(void) {
        if (sysctl_ctx_free(&clist)) {
                uprintf("sysctl_ctx_free_failed \n");
        }
        if (NULL != device_list_head) {
                mlx4_unregister_interface(&mlx4_core_test_interface);
        }
}

static void help(void) {
        uprintf("\n");
        uprintf("to run a test: \n");
        uprintf("1. choose the test MIB, and modify it 'status' leaf to 'run' \n");
        uprintf("\t i.e., >> sysctl mlx4_tests.test1.status=run \n");
        uprintf("2. read the leaf 'status' again, when its value is back to 'ready', the test finished its run \n");
        uprintf("3. read the leaf 'result' \n");
        uprintf("\t i.e., >> sysctl mlx4_tests.test1.result \n");
        uprintf("\n");
}

#undef MODULE_VERSION
#include <sys/module.h>
/* The function called at load/unload. */
static int mlx4_core_test_module_evhand(struct module *module, int event, void *arg) {
        int e = 0; /* Error, 0 for normal return status */

        switch (event) {
        case MOD_LOAD:
                e = init_sysctl();
                help();
                uprintf("Test module is up \n");
                break;
        
        case MOD_UNLOAD:
                cleanup_module();
                uprintf("Test module is down \n");
                break;
        
        default:
                e = EOPNOTSUPP; /* Error, Operation Not Supported */
                break;
        }

        return e;
}

static moduledata_t test_mod = {
        .name = "test_module",
        .evhand = mlx4_core_test_module_evhand,
};

DECLARE_MODULE(test_module, test_mod, SI_SUB_SMP, SI_ORDER_ANY);
MODULE_DEPEND(test_module, mlx4, 1, 1, 1);
