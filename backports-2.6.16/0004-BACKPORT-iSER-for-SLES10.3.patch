From: Sagi Grimberg <sagig@mellanox.com>
Subject: [PATCH] BACKPORT: iSER for SLES10.3

iSER-1.2 backport for SLES10.3 (2.6.16).

Change-Id: Ifdda2b8a668254bbd3f6de088b1cc20eb0b05532
Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
---
 .../2.6.16_sles10_sp3/include/linux/net.h          |    6 +-
 .../2.6.16_sles10_sp3/include/linux/netlink.h      |    3 +-
 .../2.6.16_sles10_sp3/include/linux/scatterlist.h  |   10 +-
 .../2.6.16_sles10_sp3/include/scsi/libiscsi.h      |   28 ++
 .../2.6.16_sles10_sp3/include/scsi/scsi_cmnd.h     |    4 +-
 .../include/scsi/scsi_transport_iscsi.h            |   28 ++
 drivers/infiniband/ulp/iser/iscsi_iser.c           |  360 ++++++++++----------
 drivers/infiniband/ulp/iser/iscsi_iser.h           |   24 +-
 drivers/infiniband/ulp/iser/iser_initiator.c       |   55 +++-
 drivers/infiniband/ulp/iser/iser_memory.c          |    6 +-
 drivers/infiniband/ulp/iser/iser_verbs.c           |   29 ++-
 11 files changed, 323 insertions(+), 230 deletions(-)
 create mode 100644 backport_includes/2.6.16_sles10_sp3/include/scsi/libiscsi.h
 create mode 100644 backport_includes/2.6.16_sles10_sp3/include/scsi/scsi_transport_iscsi.h

diff --git a/backport_includes/2.6.16_sles10_sp3/include/linux/net.h b/backport_includes/2.6.16_sles10_sp3/include/linux/net.h
index xxxxxxx..xxxxxxx xxxxxx
--- a/backport_includes/2.6.16_sles10_sp3/include/linux/net.h
+++ b/backport_includes/2.6.16_sles10_sp3/include/linux/net.h
@@ -7,18 +7,20 @@
 extern ssize_t sock_no_sendpage(struct socket *sock, struct page *page, int offset, size_t size, int flags);
 
 static inline
-int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
+int kernel_getsockname2(struct socket *sock, struct sockaddr *addr,
 			 int *addrlen)
 {
 	return sock->ops->getname(sock, addr, addrlen, 0);
 }
+#define kernel_getsockname kernel_getsockname2
 
 static inline
-int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
+int kernel_getpeername2(struct socket *sock, struct sockaddr *addr,
 			 int *addrlen)
 {
 	return sock->ops->getname(sock, addr, addrlen, 1);
 }
+#define kernel_getpeername kernel_getpeername2
 
 static inline
 int kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen)
diff --git a/backport_includes/2.6.16_sles10_sp3/include/linux/netlink.h b/backport_includes/2.6.16_sles10_sp3/include/linux/netlink.h
index xxxxxxx..xxxxxxx xxxxxx
--- a/backport_includes/2.6.16_sles10_sp3/include/linux/netlink.h
+++ b/backport_includes/2.6.16_sles10_sp3/include/linux/netlink.h
@@ -6,9 +6,10 @@
 #define netlink_kernel_create(net, uint, groups, input, mutex, mod) \
        netlink_kernel_create(uint, groups, input, mod)
 
-static inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
+static inline struct nlmsghdr *nlmsg_hdr2(const struct sk_buff *skb)
 {
 	return (struct nlmsghdr *)skb->data;
 }
+#define nlmsg_hdr nlmsg_hdr2
 
 #endif
diff --git a/backport_includes/2.6.16_sles10_sp3/include/linux/scatterlist.h b/backport_includes/2.6.16_sles10_sp3/include/linux/scatterlist.h
index xxxxxxx..xxxxxxx xxxxxx
--- a/backport_includes/2.6.16_sles10_sp3/include/linux/scatterlist.h
+++ b/backport_includes/2.6.16_sles10_sp3/include/linux/scatterlist.h
@@ -25,25 +25,30 @@ static inline void sg_assign_page(struct scatterlist *sg, struct page *page)
 	sg->page = page;
 }
 
-static inline void sg_set_page(struct scatterlist *sg, struct page *page,
+static inline void sg_set_page2(struct scatterlist *sg, struct page *page,
                                unsigned int len, unsigned int offset)
 {
 	sg->page = page;
 	sg->offset = offset;
 	sg->length = len;
 }
+#define sg_set_page sg_set_page2
 
 static inline void sg_mark_end(struct scatterlist *sg)
 {
 }
 
+#ifndef sg_page
 #define sg_page(a) (a)->page
+#endif
+#ifndef sg_init_table
 #define sg_init_table(a, b)
+#endif
 
 #define for_each_sg(sglist, sg, nr, __i)	\
 	for (__i = 0, sg = (sglist); __i < (nr); __i++, sg++)
 
-static inline struct scatterlist *sg_next(struct scatterlist *sg)
+static inline struct scatterlist *sg_next2(struct scatterlist *sg)
 {
 	if (!sg) {
 		BUG();
@@ -51,5 +56,6 @@ static inline struct scatterlist *sg_next(struct scatterlist *sg)
 	}
 	return sg + 1;
 }
+#define sg_next sg_next2
 
 #endif
diff --git a/backport_includes/2.6.16_sles10_sp3/include/scsi/libiscsi.h b/backport_includes/2.6.16_sles10_sp3/include/scsi/libiscsi.h
new file mode 100644
index 0000000..878b3ed
--- /dev/null
+++ b/backport_includes/2.6.16_sles10_sp3/include/scsi/libiscsi.h
@@ -0,0 +1,28 @@
+#ifndef SCSI_LIBISCSI_H_BACKPORT
+#define SCSI_LIBISCSI_H_BACKPORT
+
+#undef nlmsg_hdr
+#undef kernel_getsockname
+#undef kernel_getpeername
+#undef sg_set_page
+#undef sg_page
+#undef sg_next
+#undef sg_init_table
+#define kernel_getsockname static kernel_getsockname
+#define kernel_getpeername static kernel_getpeername
+
+#include_next <scsi/libiscsi.h>
+
+#define nlmsg_hdr nlmsg_hdr2
+#undef kernel_getsockname
+#undef kernel_getpeername
+#define kernel_getsockname kernel_getsockname2
+#define kernel_getpeername kernel_getpeername2
+#define sg_set_page sg_set_page2
+#undef sg_page
+#define sg_page(a) (a)->page
+#define sg_next sg_next2
+#undef sg_init_table
+#define sg_init_table(a, b)
+
+#endif
diff --git a/backport_includes/2.6.16_sles10_sp3/include/scsi/scsi_cmnd.h b/backport_includes/2.6.16_sles10_sp3/include/scsi/scsi_cmnd.h
index xxxxxxx..xxxxxxx xxxxxx
--- a/backport_includes/2.6.16_sles10_sp3/include/scsi/scsi_cmnd.h
+++ b/backport_includes/2.6.16_sles10_sp3/include/scsi/scsi_cmnd.h
@@ -7,7 +7,7 @@
 #define scsi_sglist(cmd) ((struct scatterlist *)(cmd)->request_buffer)
 #define scsi_bufflen(cmd) ((cmd)->request_bufflen)
 
-static inline void scsi_set_resid(struct scsi_cmnd *cmd, int resid)
+/*static inline void scsi_set_resid(struct scsi_cmnd *cmd, int resid)
 {
 	cmd->resid = resid;
 }
@@ -15,7 +15,7 @@ static inline void scsi_set_resid(struct scsi_cmnd *cmd, int resid)
 static inline int scsi_get_resid(struct scsi_cmnd *cmd)
 {
 	return cmd->resid;
-}
+}*/
 
 #define scsi_for_each_sg(cmd, sg, nseg, __i)			\
 	for (__i = 0, sg = scsi_sglist(cmd); __i < (nseg); __i++, (sg)++)
diff --git a/backport_includes/2.6.16_sles10_sp3/include/scsi/scsi_transport_iscsi.h b/backport_includes/2.6.16_sles10_sp3/include/scsi/scsi_transport_iscsi.h
new file mode 100644
index 0000000..e5cda51
--- /dev/null
+++ b/backport_includes/2.6.16_sles10_sp3/include/scsi/scsi_transport_iscsi.h
@@ -0,0 +1,28 @@
+#ifndef SCSI_SCSI_TRANSPORT_ISCSI_H_BACKPORT
+#define SCSI_SCSI_TRANSPORT_ISCSI_H_BACKPORT
+
+#undef nlmsg_hdr
+#undef kernel_getsockname
+#undef kernel_getpeername
+#undef sg_set_page
+#undef sg_page
+#undef sg_next
+#undef sg_init_table
+#define kernel_getsockname static kernel_getsockname
+#define kernel_getpeername static kernel_getpeername
+
+#include_next <scsi/scsi_transport_iscsi.h>
+
+#define nlmsg_hdr nlmsg_hdr2
+#undef kernel_getsockname
+#undef kernel_getpeername
+#define kernel_getsockname kernel_getsockname2
+#define kernel_getpeername kernel_getpeername2
+#define sg_set_page sg_set_page2
+#undef sg_page
+#define sg_page(a) (a)->page
+#define sg_next sg_next2
+#undef sg_init_table
+#define sg_init_table(a, b)
+
+#endif
diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -53,7 +53,7 @@
 #include <linux/ioctl.h>
 #include <linux/cdev.h>
 #include <linux/in.h>
-#include <linux/net.h>
+//#include <linux/net.h>
 #include <linux/scatterlist.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
@@ -125,16 +125,29 @@ error:
 	iscsi_conn_failure(conn, rc);
 }
 
-static int iscsi_iser_pdu_alloc(struct iscsi_task *task, uint8_t opcode)
+int iser_initialize_mtask_headers(struct iscsi_mgmt_task *task,
+				  struct iscsi_iser_conn *iser_conn,
+				  struct iser_tx_desc *tx_desc)
 {
+	struct iser_device *device = iser_conn->ib_conn->device;
 	struct iscsi_iser_task *iser_task = task->dd_data;
+	u64 dma_addr;
+
+	dma_addr = ib_dma_map_single(device->ib_device, (void *)tx_desc,
+				ISER_HEADERS_LEN, DMA_TO_DEVICE);
+	if (ib_dma_mapping_error(device->ib_device, dma_addr))
+		return -ENOMEM;
+
+	tx_desc->dma_addr = dma_addr;
+	tx_desc->tx_sg[0].addr   = tx_desc->dma_addr;
+	tx_desc->tx_sg[0].length = ISER_HEADERS_LEN;
+	tx_desc->tx_sg[0].lkey   = device->mr->lkey;
 
-	task->hdr = (struct iscsi_hdr *)&iser_task->desc.iscsi_header;
-	task->hdr_max = sizeof(iser_task->desc.iscsi_header);
+	iser_task->iser_conn = iser_conn;
 	return 0;
 }
 
-int iser_initialize_task_headers(struct iscsi_task *task,
+int iser_initialize_task_headers(struct iscsi_cmd_task *task,
 						struct iser_tx_desc *tx_desc)
 {
 	struct iscsi_iser_conn *iser_conn = task->conn->dd_data;
@@ -155,6 +168,7 @@ int iser_initialize_task_headers(struct iscsi_task *task,
 	iser_task->iser_conn		= iser_conn;
 	return 0;
 }
+
 /**
  * iscsi_iser_task_init - Initialize task
  * @task: iscsi task
@@ -162,17 +176,13 @@ int iser_initialize_task_headers(struct iscsi_task *task,
  * Initialize the task for the scsi command or mgmt command.
  */
 static int
-iscsi_iser_task_init(struct iscsi_task *task)
+iscsi_iser_task_init(struct iscsi_cmd_task *task)
 {
 	struct iscsi_iser_task *iser_task = task->dd_data;
 
 	if (iser_initialize_task_headers(task, &iser_task->desc))
 			return -ENOMEM;
 
-	/* mgmt task */
-	if (!task->sc)
-		return 0;
-
 	iser_task->command_sent = 0;
 	iser_task_rdma_init(iser_task);
 	return 0;
@@ -190,7 +200,7 @@ iscsi_iser_task_init(struct iscsi_task *task)
  *
  **/
 static int
-iscsi_iser_mtask_xmit(struct iscsi_conn *conn, struct iscsi_task *task)
+iscsi_iser_mtask_xmit(struct iscsi_conn *conn, struct iscsi_mgmt_task *task)
 {
 	int error = 0;
 
@@ -209,28 +219,27 @@ iscsi_iser_mtask_xmit(struct iscsi_conn *conn, struct iscsi_task *task)
 
 static int
 iscsi_iser_task_xmit_unsol_data(struct iscsi_conn *conn,
-				 struct iscsi_task *task)
+				 struct iscsi_cmd_task *task)
 {
-	struct iscsi_r2t_info *r2t = &task->unsol_r2t;
 	struct iscsi_data hdr;
 	int error = 0;
 
 	/* Send data-out PDUs while there's still unsolicited data to send */
-	while (iscsi_task_has_unsol_data(task)) {
-		iscsi_prep_data_out_pdu(task, r2t, &hdr);
+	while (task->unsol_count > 0) {
+		iscsi_prep_unsolicit_data_pdu(task, &hdr);
 		iser_dbg("Sending data-out: itt 0x%x, data count %d\n",
-			   hdr.itt, r2t->data_count);
+			   hdr.itt, task->data_count);
 
 		/* the buffer description has been passed with the command */
 		/* Send the command */
 		error = iser_send_data_out(conn, task, &hdr);
 		if (error) {
-			r2t->datasn--;
+			task->unsol_datasn--;
 			goto iscsi_iser_task_xmit_unsol_data_exit;
 		}
-		r2t->sent += r2t->data_count;
+		task->unsol_count -= task->data_count;
 		iser_dbg("Need to send %d more as data-out PDUs\n",
-			   r2t->data_length - r2t->sent);
+			 task->unsol_count);
 	}
 
 iscsi_iser_task_xmit_unsol_data_exit:
@@ -238,23 +247,12 @@ iscsi_iser_task_xmit_unsol_data_exit:
 }
 
 static int
-iscsi_iser_task_xmit(struct iscsi_task *task)
+iscsi_iser_task_xmit(struct iscsi_conn *conn,
+		     struct iscsi_cmd_task *task)
 {
-	struct iscsi_conn *conn = task->conn;
 	struct iscsi_iser_task *iser_task = task->dd_data;
 	int error = 0;
 
-	if (!task->sc)
-		return iscsi_iser_mtask_xmit(conn, task);
-
-	if (task->sc->sc_data_direction == DMA_TO_DEVICE) {
-		BUG_ON(scsi_bufflen(task->sc) == 0);
-
-		iser_dbg("cmd [itt %x total %d imm %d unsol_data %d\n",
-			   task->itt, scsi_bufflen(task->sc),
-			   task->imm_count, task->unsol_r2t.data_length);
-	}
-
 	iser_dbg("ctask xmit [cid %d itt 0x%x]\n",
 		   conn->id, task->itt);
 
@@ -267,14 +265,15 @@ iscsi_iser_task_xmit(struct iscsi_task *task)
 	}
 
 	/* Send unsolicited data-out PDU(s) if necessary */
-	if (iscsi_task_has_unsol_data(task))
+	if (task->unsol_count)
 		error = iscsi_iser_task_xmit_unsol_data(conn, task);
 
  iscsi_iser_task_xmit_exit:
 	return error;
 }
 
-static void iscsi_iser_cleanup_task(struct iscsi_task *task)
+static void iscsi_iser_cleanup_task(struct iscsi_conn *conn,
+				    struct iscsi_cmd_task *task)
 {
 	struct iscsi_iser_task *iser_task = task->dd_data;
 	struct iser_tx_desc	*tx_desc = &iser_task->desc;
@@ -295,6 +294,24 @@ static void iscsi_iser_cleanup_task(struct iscsi_task *task)
 	}
 }
 
+static struct iser_conn *
+iscsi_iser_ib_conn_lookup(__u64 ep_handle)
+{
+	struct iser_conn *ib_conn;
+	struct iser_conn *uib_conn = (struct iser_conn *)(unsigned long)ep_handle;
+
+	mutex_lock(&ig.connlist_mutex);
+	list_for_each_entry(ib_conn, &ig.connlist, conn_list) {
+		if (ib_conn == uib_conn) {
+			mutex_unlock(&ig.connlist_mutex);
+			return ib_conn;
+		}
+	}
+	mutex_unlock(&ig.connlist_mutex);
+	iser_err("no conn exists for eph %llx\n",(unsigned long long)ep_handle);
+	return NULL;
+}
+
 static struct iscsi_cls_conn *
 iscsi_iser_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
 {
@@ -302,7 +319,7 @@ iscsi_iser_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
 	struct iscsi_cls_conn *cls_conn;
 	struct iscsi_iser_conn *iser_conn;
 
-	cls_conn = iscsi_conn_setup(cls_session, sizeof(*iser_conn), conn_idx);
+	cls_conn = iscsi_conn_setup(cls_session, conn_idx);
 	if (!cls_conn)
 		return NULL;
 	conn = cls_conn->dd_data;
@@ -313,11 +330,21 @@ iscsi_iser_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
 	 */
 	conn->max_recv_dlength = ISER_RECV_DATA_SEG_LEN;
 
-	iser_conn = conn->dd_data;
+        iser_conn = kzalloc(sizeof(*iser_conn), GFP_KERNEL);
+        if (!iser_conn)
+                goto conn_alloc_fail;
+
+	/* currently this is the only field which need to be initiated */
+	rwlock_init(&iser_conn->lock);
+
 	conn->dd_data = iser_conn;
 	iser_conn->iscsi_conn = conn;
 
 	return cls_conn;
+
+conn_alloc_fail:
+        iscsi_conn_teardown(cls_conn);
+        return NULL;
 }
 
 static void
@@ -348,7 +375,6 @@ iscsi_iser_conn_bind(struct iscsi_cls_session *cls_session,
 	struct iscsi_iser_conn *iser_conn;
 	struct iscsi_session *session;
 	struct iser_conn *ib_conn;
-	struct iscsi_endpoint *ep;
 	int error;
 
 	error = iscsi_conn_bind(cls_session, cls_conn, is_leading);
@@ -357,13 +383,12 @@ iscsi_iser_conn_bind(struct iscsi_cls_session *cls_session,
 
 	/* the transport ep handle comes from user space so it must be
 	 * verified against the global ib connections list */
-	ep = iscsi_lookup_endpoint(transport_eph);
-	if (!ep) {
-		iser_err("can't bind eph %llx\n",
-			 (unsigned long long)transport_eph);
-		return -EINVAL;
+	ib_conn = iscsi_iser_ib_conn_lookup(transport_eph);
+	if (!ib_conn) {
+		 iser_err("can't bind eph %llx\n",
+			  (unsigned long long)transport_eph);
+		  return -EINVAL;
 	}
-	ib_conn = ep->dd_data;
 
 	session = conn->session;
 	if (iser_alloc_rx_descriptors(ib_conn, session))
@@ -377,6 +402,7 @@ iscsi_iser_conn_bind(struct iscsi_cls_session *cls_session,
 	iser_conn = conn->dd_data;
 	ib_conn->iser_conn = iser_conn;
 	iser_conn->ib_conn  = ib_conn;
+	conn->recv_lock = &iser_conn->lock;
 	iser_conn_get(ib_conn); /* ref iscsi/ib conn binding */
 	return 0;
 }
@@ -403,68 +429,53 @@ iscsi_iser_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 	iser_conn->ib_conn = NULL;
 }
 
-static void iscsi_iser_session_destroy(struct iscsi_cls_session *cls_session)
-{
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
-
-	iscsi_session_teardown(cls_session);
-	iscsi_host_remove(shost);
-	iscsi_host_free(shost);
-}
-
 static struct iscsi_cls_session *
-iscsi_iser_session_create(struct iscsi_endpoint *ep,
-			  uint16_t cmds_max, uint16_t qdepth,
-			  uint32_t initial_cmdsn)
+iscsi_iser_session_create(struct iscsi_transport *iscsit,
+                         struct scsi_transport_template *scsit,
+                         uint16_t cmds_max, uint16_t qdepth,
+                         uint32_t initial_cmdsn, uint32_t *hostno)
 {
-	struct iscsi_cls_session *cls_session;
-	struct iscsi_session *session;
-	struct Scsi_Host *shost;
-	struct iser_conn *ib_conn = NULL;
-
-	shost = iscsi_host_alloc(&iscsi_iser_sht, 0, 0);
-	if (!shost)
-		return NULL;
-	shost->transportt = iscsi_iser_scsi_transport;
-	shost->cmd_per_lun = qdepth;
-	shost->max_lun = iscsi_max_lun;
-	shost->max_id = 0;
-	shost->max_channel = 0;
-	shost->max_cmd_len = 16;
-
-	/*
-	 * older userspace tools (before 2.0-870) did not pass us
-	 * the leading conn's ep so this will be NULL;
-	 */
-	if (ep)
-		ib_conn = ep->dd_data;
-
-	if (iscsi_host_add(shost,
-			   ep ? ib_conn->device->ib_device->dma_device : NULL))
-		goto free_host;
-
-	if (cmds_max > ISER_DEF_XMIT_CMDS_MAX) {
-		iser_info("cmds_max changed from %u to %u\n",
-			  cmds_max, ISER_DEF_XMIT_CMDS_MAX);
-		cmds_max = ISER_DEF_XMIT_CMDS_MAX;
-	}
-
-	cls_session = iscsi_session_setup(&iscsi_iser_transport, shost,
-					  cmds_max, 0,
-					  sizeof(struct iscsi_iser_task),
-					  initial_cmdsn, 0);
-	if (!cls_session)
-		goto remove_host;
-	session = cls_session->dd_data;
-
-	shost->can_queue = session->scsi_cmds_max;
-	return cls_session;
-
-remove_host:
-	iscsi_host_remove(shost);
-free_host:
-	iscsi_host_free(shost);
-	return NULL;
+        struct iscsi_cls_session *cls_session;
+        struct iscsi_session *session;
+        int i;
+        uint32_t hn;
+        struct iscsi_cmd_task  *ctask;
+        struct iscsi_mgmt_task *mtask;
+        struct iscsi_iser_task *iser_ctask;
+	struct iser_tx_desc *desc;
+
+        /*
+         * we do not support setting can_queue cmd_per_lun from userspace yet
+         * because we preallocate so many resources
+         */
+        cls_session = iscsi_session_setup(iscsit, scsit,
+                                          ISCSI_DEF_XMIT_CMDS_MAX,
+                                          ISCSI_MAX_CMD_PER_LUN,
+                                          sizeof(struct iscsi_iser_task),
+                                          sizeof(struct iser_tx_desc),
+                                          initial_cmdsn, &hn);
+        if (!cls_session)
+        return NULL;
+
+        *hostno = hn;
+        session = class_to_transport_session(cls_session);
+
+        /* libiscsi setup itts, data and pool so just set desc fields */
+        for (i = 0; i < session->cmds_max; i++) {
+                ctask      = session->cmds[i];
+                iser_ctask = ctask->dd_data;
+                ctask->hdr = (struct iscsi_cmd *)&iser_ctask->desc.iscsi_header;
+                ctask->hdr_max = sizeof(iser_ctask->desc.iscsi_header);
+        }
+
+        for (i = 0; i < session->mgmtpool_max; i++) {
+                mtask      = session->mgmt_cmds[i];
+                desc       = mtask->dd_data;
+                mtask->hdr = &desc->iscsi_header;
+                //desc->data = mtask->data;
+        }
+
+        return cls_session;
 }
 
 static int
@@ -533,8 +544,6 @@ iscsi_iser_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *s
 	stats->custom[1].value = 0; /* TB iser_conn->fmr_map_not_avail */;
 	strcpy(stats->custom[2].desc, "eh_abort_cnt");
 	stats->custom[2].value = conn->eh_abort_cnt;
-	strcpy(stats->custom[3].desc, "fmr_unalign_cnt");
-	stats->custom[3].value = conn->fmr_unalign_cnt;
 }
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined(CONFIG_COMPAT_ISCSI_ISER_GET_EP_PARAM)
@@ -562,37 +571,34 @@ static int iscsi_iser_get_ep_param(struct iscsi_endpoint *ep,
 }
 #endif
 
-static struct iscsi_endpoint *
-iscsi_iser_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,
-		      int non_blocking)
+static int
+iscsi_iser_ep_connect(struct sockaddr *dst_addr, int non_blocking,
+                      __u64 *ep_handle)
 {
-	int err;
-	struct iser_conn *ib_conn;
-	struct iscsi_endpoint *ep;
+        int err;
+        struct iser_conn *ib_conn;
 
-	ep = iscsi_create_endpoint(sizeof(*ib_conn));
-	if (!ep)
-		return ERR_PTR(-ENOMEM);
+        err = iser_conn_init(&ib_conn);
+        if (err)
+                goto out;
 
-	ib_conn = ep->dd_data;
-	ib_conn->ep = ep;
-	iser_conn_init(ib_conn);
+        err = iser_connect(ib_conn, NULL, (struct sockaddr_in *)dst_addr, non_blocking);
+        if (!err)
+                *ep_handle = (__u64)(unsigned long)ib_conn;
 
-	err = iser_connect(ib_conn, NULL, (struct sockaddr_in *)dst_addr,
-			   non_blocking);
-	if (err)
-		return ERR_PTR(err);
-
-	return ep;
+out:
+        return err;
 }
 
 static int
-iscsi_iser_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)
+iscsi_iser_ep_poll(__u64 ep_handle, int timeout_ms)
 {
-	struct iser_conn *ib_conn;
-	int rc;
+        struct iser_conn *ib_conn = iscsi_iser_ib_conn_lookup(ep_handle);
+        int rc;
+
+        if (!ib_conn)
+                return -EINVAL;
 
-	ib_conn = ep->dd_data;
 	rc = wait_event_interruptible_timeout(ib_conn->wait,
 			     ib_conn->state == ISER_CONN_UP,
 			     msecs_to_jiffies(timeout_ms));
@@ -614,21 +620,13 @@ iscsi_iser_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)
 }
 
 static void
-iscsi_iser_ep_disconnect(struct iscsi_endpoint *ep)
+iscsi_iser_ep_disconnect(__u64 ep_handle)
 {
-	struct iser_conn *ib_conn;
-
-	ib_conn = ep->dd_data;
-	if (ib_conn->iser_conn)
-		/*
-		 * Must suspend xmit path if the ep is bound to the
-		 * iscsi_conn, so we know we are not accessing the ib_conn
-		 * when we free it.
-		 *
-		 * This may not be bound if the ep poll failed.
-		 */
-		iscsi_suspend_tx(ib_conn->iser_conn->iscsi_conn);
+        struct iser_conn *ib_conn;
 
+        ib_conn = iscsi_iser_ib_conn_lookup(ep_handle);
+        if (!ib_conn)
+                return;
 
 	iser_info("ib conn %p state %d\n", ib_conn, ib_conn->state);
 	iser_conn_terminate(ib_conn);
@@ -696,18 +694,13 @@ static struct scsi_host_template iscsi_iser_sht = {
 	.module                 = THIS_MODULE,
 	.name                   = "iSCSI Initiator over iSER",
 	.queuecommand           = iscsi_queuecommand,
-	.change_queue_depth	= iscsi_change_queue_depth,
+	.can_queue		= ISCSI_DEF_XMIT_CMDS_MAX - 1,
 	.sg_tablesize           = ISCSI_ISER_SG_TABLESIZE,
 	.max_sectors		= 1024,
-	.cmd_per_lun            = ISER_DEF_CMD_PER_LUN,
+	.cmd_per_lun            = ISCSI_MAX_CMD_PER_LUN,
 	.eh_abort_handler       = iscsi_eh_abort,
 	.eh_device_reset_handler= iscsi_eh_device_reset,
-#if defined(CONFIG_COMPAT_ISCSI_EH_TARGET_RESET)
-	.eh_target_reset_handler = iscsi_eh_target_reset,
-#else
-	.eh_target_reset_handler = iscsi_eh_recover_target,
-#endif
-	.target_alloc		= iscsi_target_alloc,
+	.eh_host_reset_handler  = iscsi_eh_host_reset,
 	.use_clustering         = DISABLE_CLUSTERING,
 	.proc_name              = "iscsi_iser",
 	.this_id                = -1,
@@ -717,47 +710,38 @@ static struct iscsi_transport iscsi_iser_transport = {
 	.owner                  = THIS_MODULE,
 	.name                   = "iser",
 	.caps                   = CAP_RECOVERY_L0 | CAP_MULTI_R2T,
-#if defined(CONFIG_COMPAT_ISCSI_TRANSPORT_PARAM_MASK)
-        .param_mask             = ISCSI_MAX_RECV_DLENGTH |
-                                  ISCSI_MAX_XMIT_DLENGTH |
-                                  ISCSI_HDRDGST_EN |
-                                  ISCSI_DATADGST_EN |
-                                  ISCSI_INITIAL_R2T_EN |
-                                  ISCSI_MAX_R2T |
-                                  ISCSI_IMM_DATA_EN |
-                                  ISCSI_FIRST_BURST |
-                                  ISCSI_MAX_BURST |
-                                  ISCSI_PDU_INORDER_EN |
-                                  ISCSI_DATASEQ_INORDER_EN |
-                                  ISCSI_EXP_STATSN |
-                                  ISCSI_PERSISTENT_PORT |
-                                  ISCSI_PERSISTENT_ADDRESS |
-                                  ISCSI_TARGET_NAME | ISCSI_TPGT |
-                                  ISCSI_USERNAME | ISCSI_PASSWORD |
-                                  ISCSI_USERNAME_IN | ISCSI_PASSWORD_IN |
-                                  ISCSI_FAST_ABORT | ISCSI_ABORT_TMO |
-                                  ISCSI_LU_RESET_TMO | ISCSI_TGT_RESET_TMO |
-                                  ISCSI_PING_TMO | ISCSI_RECV_TMO |
-                                  ISCSI_IFACE_NAME | ISCSI_INITIATOR_NAME,
-        .host_param_mask        = ISCSI_HOST_HWADDRESS |
-                                  ISCSI_HOST_NETDEV_NAME |
-                                  ISCSI_HOST_INITIATOR_NAME,
+	.param_mask		= ISCSI_MAX_RECV_DLENGTH |
+				  ISCSI_MAX_XMIT_DLENGTH |
+				  ISCSI_HDRDGST_EN |
+				  ISCSI_DATADGST_EN |
+				  ISCSI_INITIAL_R2T_EN |
+				  ISCSI_MAX_R2T |
+				  ISCSI_IMM_DATA_EN |
+				  ISCSI_FIRST_BURST |
+				  ISCSI_MAX_BURST |
+				  ISCSI_PDU_INORDER_EN |
+				  ISCSI_DATASEQ_INORDER_EN |
+				  ISCSI_EXP_STATSN |
+				  ISCSI_PERSISTENT_PORT |
+				  ISCSI_PERSISTENT_ADDRESS |
+				  ISCSI_TARGET_NAME |
+				  ISCSI_TPGT,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+	.host_template          = &iscsi_iser_sht,
 #endif
+	.conndata_size		= sizeof(struct iscsi_conn),
+	.max_lun                = ISCSI_ISER_MAX_LUN,
+	.max_conn               = 1,
+	.max_cmd_len            = ISCSI_ISER_MAX_CMD_LEN,
 	/* session management */
 	.create_session         = iscsi_iser_session_create,
-	.destroy_session        = iscsi_iser_session_destroy,
+	.destroy_session        = iscsi_session_teardown,
 	/* connection management */
 	.create_conn            = iscsi_iser_conn_create,
 	.bind_conn              = iscsi_iser_conn_bind,
 	.destroy_conn           = iscsi_iser_conn_destroy,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0)) || defined(CONFIG_COMPAT_ISER_ATTR_IS_VISIBLE)
-	.attr_is_visible	= iser_attr_is_visible,
-#endif
 	.set_param              = iscsi_iser_set_param,
 	.get_conn_param		= iscsi_conn_get_param,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined(CONFIG_COMPAT_ISCSI_ISER_GET_EP_PARAM)
-	.get_ep_param		= iscsi_iser_get_ep_param,
-#endif
 	.get_session_param	= iscsi_session_get_param,
 	.start_conn             = iscsi_conn_start,
 	.stop_conn              = iscsi_iser_conn_stop,
@@ -767,10 +751,10 @@ static struct iscsi_transport iscsi_iser_transport = {
 	/* IO */
 	.send_pdu		= iscsi_conn_send_pdu,
 	.get_stats		= iscsi_iser_conn_get_stats,
-	.init_task		= iscsi_iser_task_init,
-	.xmit_task		= iscsi_iser_task_xmit,
-	.cleanup_task		= iscsi_iser_cleanup_task,
-	.alloc_pdu		= iscsi_iser_pdu_alloc,
+	.init_cmd_task		= iscsi_iser_task_init,
+	.xmit_cmd_task		= iscsi_iser_task_xmit,
+	.xmit_mgmt_task         = iscsi_iser_mtask_xmit,
+	.cleanup_cmd_task	= iscsi_iser_cleanup_task,
 	/* recovery */
 	.session_recovery_timedout = iscsi_session_recovery_timedout,
 
@@ -783,13 +767,15 @@ static int __init iser_init(void)
 {
 	int err;
 
-	iser_dbg("Starting iSER datamover...\n");
+	iser_info("Starting iSER datamover...\n");
 
 	if (iscsi_max_lun < 1) {
 		iser_err("Invalid max_lun value of %u\n", iscsi_max_lun);
 		return -EINVAL;
 	}
 
+	iscsi_iser_transport.max_lun = iscsi_max_lun;
+
 	memset(&ig, 0, sizeof(struct iser_global));
 
 	ig.desc_cache = kmem_cache_create("iser_descriptors",
@@ -824,7 +810,7 @@ register_transport_failure:
 static void __exit iser_exit(void)
 {
 	int logger_count = 10;
-	iser_dbg("Removing iSER datamover...\n");
+	iser_info("Removing iSER datamover...\n");
 	iscsi_unregister_transport(&iscsi_iser_transport);
 	/*
 	This flow is a workarround to fix issue 31475.
@@ -841,7 +827,7 @@ static void __exit iser_exit(void)
 		} else {
 			mutex_unlock(&ig.device_list_mutex);
 			if (logger_count == 0) {
-				iser_err("ib_iser unload: device list is NOT empty. Postpone module unload.\n");
+				iser_dbg("ib_iser unload: device list is NOT empty. Postpone module unload.\n");
 				logger_count = 10;
 			}
 			msleep(1000);
diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.h b/drivers/infiniband/ulp/iser/iscsi_iser.h
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@ -56,14 +56,14 @@
 #include <linux/mempool.h>
 #include <linux/uio.h>
 
-#include <linux/socket.h>
-#include <linux/in.h>
-#include <linux/in6.h>
-
 #include <rdma/ib_verbs.h>
 #include <rdma/ib_fmr_pool.h>
 #include <rdma/rdma_cm.h>
 
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+
 #define DRV_NAME	"iser"
 #define PFX		DRV_NAME ": "
 #define DRV_VER		"1.2"
@@ -101,6 +101,8 @@
 
 					/* support up to 512KB in one RDMA */
 #define ISCSI_ISER_SG_TABLESIZE         (0x80000 >> SHIFT_4K)
+#define ISCSI_ISER_MAX_LUN		256
+#define ISCSI_ISER_MAX_CMD_LEN		16
 #define ISER_DEF_XMIT_CMDS_DEFAULT		512
 #if ISCSI_DEF_XMIT_CMDS_MAX > ISER_DEF_XMIT_CMDS_DEFAULT
 	#define ISER_DEF_XMIT_CMDS_MAX		ISCSI_DEF_XMIT_CMDS_MAX
@@ -318,6 +320,7 @@ struct iser_conn {
 struct iscsi_iser_conn {
 	struct iscsi_conn            *iscsi_conn;/* ptr to iscsi conn */
 	struct iser_conn             *ib_conn;   /* iSER IB conn      */
+	rwlock_t                     lock;
 };
 
 struct iscsi_iser_task {
@@ -359,13 +362,13 @@ extern int iser_debug_level;
 int iser_conn_set_full_featured_mode(struct iscsi_conn *conn);
 
 int iser_send_control(struct iscsi_conn *conn,
-		      struct iscsi_task *task);
+		      struct iscsi_mgmt_task *task);
 
 int iser_send_command(struct iscsi_conn *conn,
-		      struct iscsi_task *task);
+		      struct iscsi_cmd_task *task);
 
 int iser_send_data_out(struct iscsi_conn *conn,
-		       struct iscsi_task *task,
+		       struct iscsi_cmd_task *task,
 		       struct iscsi_data *hdr);
 
 void iscsi_iser_recv(struct iscsi_conn *conn,
@@ -373,7 +376,7 @@ void iscsi_iser_recv(struct iscsi_conn *conn,
 		     char                   *rx_data,
 		     int                    rx_data_len);
 
-void iser_conn_init(struct iser_conn *ib_conn);
+int iser_conn_init(struct iser_conn **ibconn);
 
 void iser_conn_get(struct iser_conn *ib_conn);
 
@@ -425,8 +428,11 @@ int iser_dma_map_task_data(struct iscsi_iser_task *iser_task,
 			    enum   dma_data_direction  dma_dir);
 
 void iser_dma_unmap_task_data(struct iscsi_iser_task *iser_task);
-int  iser_initialize_task_headers(struct iscsi_task *task,
+int  iser_initialize_task_headers(struct iscsi_cmd_task *task,
 			struct iser_tx_desc *tx_desc);
+int iser_initialize_mtask_headers(struct iscsi_mgmt_task *task,
+				  struct iscsi_iser_conn *iser_conn,
+				  struct iser_tx_desc *tx_desc);
 int iser_alloc_rx_descriptors(struct iser_conn *ib_conn, struct iscsi_session *session);
 int iser_create_fmr_pool(struct iser_conn *ib_conn, unsigned cmds_max);
 void iser_free_fmr_pool(struct iser_conn *ib_conn);
diff --git a/drivers/infiniband/ulp/iser/iser_initiator.c b/drivers/infiniband/ulp/iser/iser_initiator.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@ -43,7 +43,7 @@
  *  dto descriptor. Total data size is stored in
  *  iser_task->data[ISER_DIR_IN].data_len
  */
-static int iser_prepare_read_cmd(struct iscsi_task *task,
+static int iser_prepare_read_cmd(struct iscsi_cmd_task *task,
 				 unsigned int edtl)
 
 {
@@ -92,7 +92,7 @@ static int iser_prepare_read_cmd(struct iscsi_task *task,
  *  task->data[ISER_DIR_OUT].data_len
  */
 static int
-iser_prepare_write_cmd(struct iscsi_task *task,
+iser_prepare_write_cmd(struct iscsi_cmd_task *task,
 		       unsigned int imm_sz,
 		       unsigned int unsol_sz,
 		       unsigned int edtl)
@@ -254,7 +254,7 @@ int iser_alloc_rx_descriptors(struct iser_conn *ib_conn, struct iscsi_session *s
 	ib_conn->qp_max_recv_dtos_mask = session->cmds_max - 1; /* cmds_max is 2^N */
 	ib_conn->min_posted_rx = ib_conn->qp_max_recv_dtos >> 2;
 
-	if (device->iser_alloc_rdma_res(ib_conn, session->scsi_cmds_max))
+	if (device->iser_alloc_rdma_res(ib_conn, ISCSI_DEF_XMIT_CMDS_MAX))
 		goto create_rdma_reg_res_failed;
 
 	if (iser_alloc_login_buf(ib_conn))
@@ -354,7 +354,7 @@ static int iser_post_rx_bufs(struct iscsi_conn *conn, struct iscsi_hdr *req)
  * iser_send_command - send command PDU
  */
 int iser_send_command(struct iscsi_conn *conn,
-		      struct iscsi_task *task)
+		      struct iscsi_cmd_task *task)
 {
 	struct iscsi_iser_conn *iser_conn = conn->dd_data;
 	struct iscsi_iser_task *iser_task = task->dd_data;
@@ -396,7 +396,7 @@ int iser_send_command(struct iscsi_conn *conn,
 		err = iser_prepare_write_cmd(task,
 					     task->imm_count,
 				             task->imm_count +
-					     task->unsol_r2t.data_length,
+					     task->unsol_count,
 					     edtl);
 		if (err)
 			goto send_command_error;
@@ -417,7 +417,7 @@ send_command_error:
  * iser_send_data_out - send data out PDU
  */
 int iser_send_data_out(struct iscsi_conn *conn,
-		       struct iscsi_task *task,
+		       struct iscsi_cmd_task *task,
 		       struct iscsi_data *hdr)
 {
 	struct iscsi_iser_conn *iser_conn = conn->dd_data;
@@ -480,7 +480,7 @@ send_data_out_error:
 }
 
 int iser_send_control(struct iscsi_conn *conn,
-		      struct iscsi_task *task)
+		      struct iscsi_mgmt_task *task)
 {
 	struct iscsi_iser_conn *iser_conn = conn->dd_data;
 	struct iscsi_iser_task *iser_task = task->dd_data;
@@ -492,15 +492,18 @@ int iser_send_control(struct iscsi_conn *conn,
 
 	/* build the tx desc regd header and add it to the tx desc dto */
 	mdesc->type = ISCSI_TX_CONTROL;
+
+	/* build the tx desc */
+	iser_initialize_mtask_headers(task, iser_conn, mdesc);
+
 	iser_create_send_desc(iser_conn->ib_conn, mdesc);
 
 	device = iser_conn->ib_conn->device;
-
 	data_seg_len = ntoh24(task->hdr->dlength);
 
 	if (data_seg_len > 0) {
 		struct ib_sge *tx_dsg = &mdesc->tx_sg[1];
-		if (task != conn->login_task) {
+		if (task != conn->login_mtask) {
 			iser_err("data present on non login task!!!\n");
 			goto send_control_error;
 		}
@@ -522,7 +525,7 @@ int iser_send_control(struct iscsi_conn *conn,
 		mdesc->num_sge = 2;
 	}
 
-	if (task == conn->login_task) {
+	if (task == conn->login_mtask) {
 		err = iser_post_recvl(iser_conn->ib_conn);
 		if (err)
 			goto send_control_error;
@@ -548,9 +551,14 @@ void iser_rcv_completion(struct iser_rx_desc *rx_desc,
 			 struct iser_conn *ib_conn)
 {
 	struct iscsi_iser_conn *conn = ib_conn->iser_conn;
+	struct iscsi_session *session = conn->iscsi_conn->session;
+	struct iscsi_cmd_task *task;
+	struct iscsi_iser_task *iser_task;
 	struct iscsi_hdr *hdr;
 	u64 rx_dma;
 	int rx_buflen, outstanding, count, err;
+	unsigned int itt;
+	unsigned char opcode;
 
 	/* differentiate between login to all other PDUs */
 	if ((char *)rx_desc == ib_conn->login_resp_buf) {
@@ -569,6 +577,21 @@ void iser_rcv_completion(struct iser_rx_desc *rx_desc,
 	iser_dbg("op 0x%x itt 0x%x dlen %d\n", hdr->opcode,
 			hdr->itt, (int)(rx_xfer_len - ISER_HEADERS_LEN));
 
+	opcode = hdr->opcode & ISCSI_OPCODE_MASK;
+        if (opcode == ISCSI_OP_SCSI_CMD_RSP) {
+                itt = get_itt(hdr->itt); /* mask out cid and age bits */
+                if (!(itt < session->cmds_max))
+                        iser_err("itt can't be matched to task!!! "
+                                 "conn %p opcode %d cmds_max %d itt %d\n",
+                                 conn->iscsi_conn, opcode, session->cmds_max, itt);
+                /* use the mapping given with the cmds array indexed by itt */
+                task = (struct iscsi_cmd_task *)session->cmds[itt];
+                iser_task = task->dd_data;
+                iser_dbg("itt %d ctask %p\n", itt, task);
+                iser_task->status = ISER_TASK_STATUS_COMPLETED;
+                iser_task_rdma_finalize(iser_task);
+        }
+
 	iscsi_iser_recv(conn->iscsi_conn, hdr,
 		rx_desc->data, rx_xfer_len - ISER_HEADERS_LEN);
 
@@ -597,7 +620,8 @@ void iser_rcv_completion(struct iser_rx_desc *rx_desc,
 void iser_snd_completion(struct iser_tx_desc *tx_desc,
 			struct iser_conn *ib_conn)
 {
-	struct iscsi_task *task;
+	struct iscsi_mgmt_task *task;
+	struct iscsi_conn *conn = ib_conn->iser_conn->iscsi_conn;
 	struct iser_device *device = ib_conn->device;
 
 	if (tx_desc->type == ISCSI_TX_DATAOUT) {
@@ -611,9 +635,12 @@ void iser_snd_completion(struct iser_tx_desc *tx_desc,
 	if (tx_desc->type == ISCSI_TX_CONTROL) {
 		/* this arithmetic is legal by libiscsi dd_data allocation */
 		task = (void *) ((long)(void *)tx_desc -
-				  sizeof(struct iscsi_task));
-		if (task->hdr->itt == RESERVED_ITT)
-			iscsi_put_task(task);
+				  sizeof(struct iscsi_mgmt_task));
+		if (task->hdr->itt == RESERVED_ITT) {
+			spin_lock(&conn->session->lock);
+			iscsi_free_mgmt_task(conn, task);
+			spin_unlock(&conn->session->lock);
+		}
 	}
 }
 
diff --git a/drivers/infiniband/ulp/iser/iser_memory.c b/drivers/infiniband/ulp/iser/iser_memory.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@ -313,10 +313,10 @@ static void iser_dump_page_vec(struct iser_page_vec *page_vec)
 {
 	int i;
 
-	iser_err("page vec length %d data size %d\n",
+	iser_dbg("page vec length %d data size %d\n",
 		 page_vec->length, page_vec->data_size);
 	for (i = 0; i < page_vec->length; i++)
-		iser_err("%d %lx\n",i,(unsigned long)page_vec->pages[i]);
+		iser_dbg("%d %lx\n",i,(unsigned long)page_vec->pages[i]);
 }
 
 static void iser_page_vec_build(struct iser_data_buf *data,
@@ -385,10 +385,8 @@ static int fall_to_bounce_buf(struct iscsi_iser_task *iser_task,
 			      enum iser_data_dir cmd_dir,
 			      int aligned_len)
 {
-	struct iscsi_conn    *iscsi_conn = iser_task->iser_conn->iscsi_conn;
 	struct iser_data_buf *mem = &iser_task->data[cmd_dir];
 
-	iscsi_conn->fmr_unalign_cnt++;
 	iser_warn("rdma alignment violation (%d/%d aligned) or FMR not supported\n",
 		  aligned_len, mem->size);
 
diff --git a/drivers/infiniband/ulp/iser/iser_verbs.c b/drivers/infiniband/ulp/iser/iser_verbs.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@ -552,7 +552,6 @@ static void iser_conn_release(struct iser_conn *ib_conn, int can_destroy_id)
 		rdma_destroy_id(ib_conn->cma_id);
 		ib_conn->cma_id = NULL;
 	}
-	iscsi_destroy_endpoint(ib_conn->ep);
 }
 
 void iser_conn_get(struct iser_conn *ib_conn)
@@ -727,15 +726,25 @@ static int iser_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *eve
 	return ret;
 }
 
-void iser_conn_init(struct iser_conn *ib_conn)
+int iser_conn_init(struct iser_conn **ibconn)
 {
-	ib_conn->state = ISER_CONN_INIT;
+        struct iser_conn *ib_conn;
+
+        ib_conn = kzalloc(sizeof *ib_conn, GFP_KERNEL);
+        if (!ib_conn) {
+                iser_err("can't alloc memory for struct iser_conn\n");
+                return -ENOMEM;
+        }	ib_conn->state = ISER_CONN_INIT;
+
 	init_waitqueue_head(&ib_conn->wait);
 	ib_conn->post_recv_buf_count = 0;
 	atomic_set(&ib_conn->post_send_buf_count, 0);
 	atomic_set(&ib_conn->refcount, 1); /* ref ib conn allocation */
 	INIT_LIST_HEAD(&ib_conn->conn_list);
 	spin_lock_init(&ib_conn->lock);
+
+	*ibconn = ib_conn;
+	return 0;
 }
 
  /**
@@ -750,14 +759,15 @@ int iser_connect(struct iser_conn   *ib_conn,
 	struct sockaddr *src, *dst;
 	int err = 0;
 
-	sprintf(ib_conn->name, "%pI4:%d",
-		&dst_addr->sin_addr.s_addr, dst_addr->sin_port);
+        sprintf(ib_conn->name,"%d.%d.%d.%d:%d",
+                NIPQUAD(dst_addr->sin_addr.s_addr),
+		be16_to_cpu(dst_addr->sin_port));
 
-	/* the device is known only --after-- address resolution */
-	ib_conn->device = NULL;
+        /* the device is known only --after-- address resolution */
+        ib_conn->device = NULL;
 
-	iser_info("connecting to: %pI4, port 0x%x\n",
-		  &dst_addr->sin_addr, dst_addr->sin_port);
+        iser_info("connecting to: %d.%d.%d.%d:%d\n",
+                  NIPQUAD(dst_addr->sin_addr), be16_to_cpu(dst_addr->sin_port));
 
 	ib_conn->state = ISER_CONN_PENDING;
 
@@ -780,6 +790,7 @@ int iser_connect(struct iser_conn   *ib_conn,
 	}
 
 	if (!non_blocking) {
+		iser_err(" blocking!\n");
 		wait_event_interruptible(ib_conn->wait,
 					 (ib_conn->state != ISER_CONN_PENDING));
 
